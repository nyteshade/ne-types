{"version":3,"sources":["../src/types.js"],"names":["typeOf","isNativeClassByProps","isNativeClassByString","extendsFrom","object","exec","Object","prototype","toString","call","isFunction","obj","Function","name","isArray","Array","isDate","Date","isObject","isString","String","isNumber","Number","isRegExp","RegExp","isNull","NULL","isUndefined","UNDEFINED","isPrimitive","PRIMITIVES","has","isValue","isOfType","T","isClass","thing","hasOwnProperty","value","test","TestedClass","RootClass","enforceClasses","constructor","ParentClass","parseInt","process","version","substring","Error","undefined","Boolean","bind","o"],"mappings":"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","file":"types.js","sourceRoot":"src","sourcesContent":["/** @namespace types */\n/** @flow */\n\n/**\n * One common way to determine the type of class that you are working with,\n * in a fairly compatible manner, is to use .call or .apply on the function\n * toString of the Object.prototype.\n *\n * Calling `Object.prototype.toString.call('hello')` will yield\n * `\"[object String]\"` as an answer. This technique is fairly sound but is\n * also fairly verbose to use often. This function extracts the detected value\n * name from the above string; so \"String\" from \"[object String]\" and so forth.\n *\n * The added advantage of using this method is that it works well with direct\n * name comparisons, such as `typeOf(\"asdfas\") === String.name`. The new\n * `Symbol.toStringTag` allows you to define custom values that are\n * reflected in this manner.\n *\n * @method ⌾⠀typeOf\n * @memberof types\n * @inner\n *\n * @param {mixed} object any value is acceptable here, including null and\n * undefined\n * @return {string} for objects of type [object String] the value \"String\"\n * will be returned.\n */\nexport function typeOf(object: mixed): string {\n  return /(\\b\\w+\\b)\\]/.exec(Object.prototype.toString.call(object))[1];\n}\n\n/**\n * Returns true if the type supplied evaluates to `[object Function]`\n *\n * @method ⌾⠀isFunction\n * @memberof types\n * @inner\n *\n * @param {mixed} obj any object that can be passed to Object.prototype.toString\n * @return {Boolean} true if it passes the test, false otherwise\n */\nexport const isFunction = (obj: mixed) => typeOf(obj) === Function.name\n\n/**\n * Returns true if the type supplied evaluates to `[object Array]`\n *\n * @method ⌾⠀isArray\n * @memberof types\n * @inner\n *\n * @param {mixed} obj any object that can be passed to Object.prototype.toString\n * @return {Boolean} true if it passes the test, false otherwise\n */\nexport const isArray = (obj: mixed) => typeOf(obj) === Array.name\n\n/**\n * Returns true if the type supplied evaluates to `[object Date]`\n *\n * @method ⌾⠀isDate\n * @memberof types\n * @inner\n *\n * @param {mixed} obj any object that can be passed to Object.prototype.toString\n * @return {Boolean} true if it passes the test, false otherwise\n */\nexport const isDate = (obj: mixed) => typeOf(obj) === Date.name\n\n/**\n * Returns true if the type supplied evaluates to `[object Object]`\n *\n * @method ⌾⠀isObject\n * @memberof types\n * @inner\n *\n * @param {mixed} obj any object that can be passed to Object.prototype.toString\n * @return {Boolean} true if it passes the test, false otherwise\n */\nexport const isObject = (obj: mixed) => typeOf(obj) === Object.name\n\n/**\n * Returns true if the type supplied evaluates to `[object String]`\n *\n * @method ⌾⠀isString\n * @memberof types\n * @inner\n *\n * @param {mixed} obj any object that can be passed to Object.prototype.toString\n * @return {Boolean} true if it passes the test, false otherwise\n */\nexport const isString = (obj: mixed) => typeOf(obj) === String.name\n\n/**\n * Returns true if the type supplied evaluates to `[object Number]`\n *\n * @method ⌾⠀isNumber\n * @memberof types\n * @inner\n *\n * @param {mixed} obj any object that can be passed to Object.prototype.toString\n * @return {Boolean} true if it passes the test, false otherwise\n */\nexport const isNumber = (obj: mixed) => typeOf(obj) === Number.name\n\n/**\n * Returns true if the type supplied evaluates to `[object RegExp]`\n *\n * @method ⌾⠀isRegExp\n * @memberof types\n * @inner\n *\n * @param {mixed} obj any object that can be passed to Object.prototype.toString\n * @return {Boolean} true if it passes the test, false otherwise\n */\nexport const isRegExp = (obj: mixed) => typeOf(obj) === RegExp.name\n\n/**\n * Returns true if the type supplied evaluates to `[object Null]`\n *\n * @method ⌾⠀isNull\n * @memberof types\n * @inner\n *\n * @param {mixed} obj any object that can be passed to Object.prototype.toString\n * @return {Boolean} true if it passes the test, false otherwise\n */\nexport const isNull = (obj: mixed) => typeOf(obj) === NULL\n\n/**\n * Returns true if the type supplied evaluates to `[object Undefined]`\n *\n * @method ⌾⠀isUndefined\n * @memberof types\n * @inner\n *\n * @param {mixed} obj any object that can be passed to Object.prototype.toString\n * @return {Boolean} true if it passes the test, false otherwise\n */\nexport const isUndefined = (obj: mixed) => typeOf(obj) === UNDEFINED\n\n/**\n * Determines if the resulting type is one of the six types of primitives\n * (according to MDN; https://goo.gl/USmkUU). If it is, true will be returned;\n * otherwise false.\n *\n * @method ⌾⠀isPrimitive\n * @memberof types\n * @inner\n *\n * @param {mixed} obj given any value, it will return true if it is a primitive\n * @return {Boolean} true if not one of Boolean, Null, Undefined, Number,\n * String or Symbol.\n */\n// $ComputedType\nexport const isPrimitive = (obj: mixed) => PRIMITIVES.has(obj)\n\n/**\n * Returns true if the type supplied evaluates to neither `[object Object]`\n * nor `[object Array]`.\n *\n * @method ⌾⠀isValue\n * @memberof types\n * @inner\n *\n * @param {mixed} obj any object that can be passed to Object.prototype.toString\n * @return {Boolean} true if it passes the test, false otherwise\n */\nexport const isValue = (obj: mixed) => (!isObject(obj) && !isArray(obj))\n\n/**\n * A shorthand way to test an object's declared toString type to a supplied\n * string or Function/Class. Realistically, this checks typeOf(obj) to both\n * T and T.name. If either are true, then true is returned; false otherwise.\n *\n * @method ⌾⠀isOfType\n * @memberof types\n * @inner\n *\n * @param {mixed} obj any object that can be passed to Object.prototype.toString\n * @param {Function} T the type you wish to test for. Ideally this should be\n * a class/function\n * @return {Boolean} true if it passes the test, false otherwise\n */\nexport const isOfType = (\n  obj: mixed,\n  T: Function\n) => (typeOf(obj) === T || typeOf(obj) === T.name)\n\n/**\n * Returns true if the supplied obj is a ECMAScript class definition. It first\n * checks by examining the properties of the supplied class. Secondly it checks\n * by searching the toString() method of the 'function' for the term class. If\n * either are true, then true is returned; false is returned otherwise.\n *\n * NOTE Relying on this strictly, especially when used with other libraries\n * can cause some problems down the line, especially if the code wraps a class\n * instance like react-jss or other similar use cases. Use at your own peril.\n *\n * @method ⌾⠀isClass\n * @memberof types\n * @inner\n *\n * @param {mixed} obj any object who's type is to be compared as a class\n * @return {boolean} true if the obj is an ECMAScript class object; not an\n * instance. False otherwise.\n *\n * @see #isNativeClassByProps\n * @see #isNativeClassByString\n */\nexport const isClass = (obj: mixed) => (\n  isNativeClassByProps(obj) ||\n  isNativeClassByString(obj))\n\n/**\n * isNativeClass method taken from code submitted on stackoverflow. Logic and\n * basis for the test appears there. See URL below for follow up if desired.\n *\n * @see  https://stackoverflow.com/questions/29093396/how-do-you-check-the-difference-between-an-ecmascript-6-class-and-function#32235645\n *\n * @method ⌾⠀isNativeClassByProps\n * @memberof types\n * @inner\n *\n * @param {mixed} thing any type of JavaScript value to test\n * @return {boolean} true if it is a ECMAScript class by testing properties;\n * false otherwise\n */\nexport function isNativeClassByProps(thing: mixed): boolean {\n  return (\n    typeof thing === 'function'\n    && thing.hasOwnProperty('prototype')\n    && !thing.hasOwnProperty('arguments'))\n}\n\n/**\n * isNativeClass method taken from code submitted on stackoverflow. Logic and\n * basis for the test appears there. See URL below for follow up if desired.\n *\n * @see  https://stackoverflow.com/questions/29093396/how-do-you-check-the-difference-between-an-ecmascript-6-class-and-function#32235645\n *\n * @method ⌾⠀isNativeClassByString\n * @memberof types\n * @inner\n *\n * @param {mixed} thing any type of JavaScript value to test\n * @return {Boolean} true if it is a ECMAScript class by testing properties;\n * false otherwise\n */\nexport function isNativeClassByString(value: mixed):boolean {\n  return (\n    typeof value === 'function'\n    && /^\\s*class/.test(value.toString()))\n}\n\n/**\n * NOTE This function will not work on nodejs versions less than 6 as Reflect\n * is needed natively.\n *\n * The instanceof keyword only works on instances of an object and not on\n * the class objects the instances are created from.\n *\n * ```js\n * class A {}\n * class B extends A {}\n *\n * let a = new A();\n * let b = new B();\n *\n * b instanceof A; // true\n * a instanceof A; // true\n * B instanceof A; // false\n * ```\n *\n * Therefore the extendsFrom function checks this relationship at the class\n * level and not at the instance level.\n *\n * ```js\n * import { extendsFrom } from '...'\n *\n * class A {}\n * class B extends A {}\n * class C extends B {}\n *\n * extendsFrom(A, A); // true\n * extendsFrom(B, A); // true\n * extendsFrom(C, A); // true\n * extendsFrom(C, 1); // false\n * extendsFrom(B, null); // false\n * ```\n *\n * @method ⌾⠀extendsFrom\n * @memberof types\n * @inner\n *\n * @param {Function} TestedClass the class of which to test heredity\n * @param {Function} RootClass the ancestor to test for\n * @param {Boolean} enforceClasses if true, false by default, an additional\n * runtime check for the type of the supplied Class objects will be made. If\n * either is not a Function, an error is thrown.\n * @return {Boolean} true if the lineage exists; false otherwise\n *\n * @see types#isClass\n */\nexport function extendsFrom(\n TestedClass: Function,\n RootClass: Function,\n enforceClasses: boolean = false\n): boolean {\n  if (!TestedClass || !RootClass) {\n    return false;\n  }\n\n  if (TestedClass === RootClass) {\n    return true;\n  }\n\n  TestedClass = TestedClass.constructor && typeof TestedClass !== 'function'\n    ? TestedClass.constructor : TestedClass\n\n  RootClass = RootClass.constructor && typeof RootClass !== 'function'\n    ? RootClass.constructor : RootClass\n\n  let ParentClass = TestedClass;\n\n  if (parseInt(process.version.substring(1)) < 6) {\n    throw new Error(`\n      Reflect must be implemented in the JavaScript engine. This cannot be\n      polyfilled and as such, if process.version is less than 6 an error will\n      be thrown. Please try an alternate means of doing what you desire.\n    `);\n  }\n\n  if (enforceClasses) {\n    if (!isClass(TestedClass) && !isClass(RootClass)) {\n      throw new Error(`\n        When using extendsFrom() with enforceClasses true, each Function\n        argument supplied must pass the isClass() method testing. See the\n        function isClass to learn more about these requirements.\n      `);\n    }\n  }\n\n  if (!TestedClass || !RootClass) { return false; }\n  if (TestedClass === RootClass) { return true; }\n\n  do {\n    ParentClass = Reflect.getPrototypeOf(ParentClass);\n\n    if (ParentClass === RootClass) {\n      return true;\n    }\n  }\n  while (ParentClass);\n\n  return false;\n}\n\n/**\n * Programmatic constant defintion of the result of a call to\n * `typeOf(undefined)`.\n *\n * @memberof types\n * @type {string}\n * @const\n */\nexport const UNDEFINED: string = typeOf(undefined);\n\n/**\n * Programmatic constant defintion of the result of a call to\n * `typeOf(null)`.\n *\n * @memberof types\n * @type {string}\n * @const\n */\nexport const NULL: string = typeOf(null);\n\n/**\n * Create a base set containing the typeOf representations for each of the\n * known primitive types.\n *\n * @type {Set<String>}\n * @memberof types\n * @inner\n */\nconst PRIMITIVES: Set<string> = new Set([\n  NULL, UNDEFINED, Boolean.name, Number.name, String.name, Symbol.name\n]);\n\n/** Store the original has() method and bind it to PRIMITIVES; $ComputedType */\nPRIMITIVES[Symbol.for('original_has')] = PRIMITIVES.has.bind(PRIMITIVES)\n\n/**\n * Modify the PRIMITIVES `has()` method to invoke `typeOf()` on the argument\n * before passing it to the underlying has() method originally passed down from\n * the Set.prototype.\n *\n * @method has\n * @memberof PRIMITIVES\n * @inner\n *\n * @param {mixed} o any value to test to see if it qualifies as a primitive\n * @return {Boolean} true if the supplied value is a primitive, false otherwise\n */\n// $ComputedType\nPRIMITIVES.has = (o: mixed) => PRIMITIVES[Symbol.for('original_has')](typeOf(o))\n\n/**\n * When testing if a type is a primitive, it is often easier to simply verify\n * that with a list of known types. To make this dead simple, a modified `Set`\n * containing the `typeOf` results for each of the six known JavaScript\n * primitive types is exported.\n *\n * The modifications are such that a call to `has()`, on this Set only, first\n * converts the supplied values to their resulting `typeOf()` representations.\n * So, `PRIMITIVES.has(4)` would be the same as `PRIMITIVES.has('Number')`.\n *\n * @memberof types\n * @type {Set<string>}\n * @const\n */\nexport { PRIMITIVES };"]}